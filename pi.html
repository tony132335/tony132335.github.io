<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pi 极速计算器 (Chudnovsky算法)</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #0d0d0d;
            color: #00ff41;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        h1 {
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.4);
        }
        
        .tag {
            font-size: 0.8em;
            background: #222;
            padding: 2px 8px;
            border-radius: 4px;
            color: #fff;
            margin-bottom: 20px;
        }

        .controls {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            border: 1px solid #333;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        input[type="number"] {
            background: #000;
            border: 1px solid #444;
            color: #fff;
            padding: 10px;
            font-family: inherit;
            width: 120px;
            font-size: 16px;
            border-radius: 4px;
        }

        button {
            padding: 10px 24px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { background-color: #006bb3; box-shadow: 0 0 10px rgba(0, 122, 204, 0.5); }
        button:disabled { opacity: 0.5; cursor: wait; }

        .stats-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            max-width: 600px;
            margin-bottom: 10px;
        }
        
        .stat-card {
            background: #111;
            padding: 10px;
            border-left: 3px solid #007acc;
        }
        
        .stat-label { color: #888; font-size: 0.9em; display: block; }
        .stat-value { color: #fff; font-size: 1.2em; font-weight: bold; }

        #status-text {
            height: 20px;
            color: #ff9800;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #result-area {
            flex: 1;
            width: 100%;
            max-width: 1200px;
            background-color: #000;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
            overflow-y: auto;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
            color: #ccc;
        }
        
        .first-digits { color: #fff; font-weight: bold; }
    </style>
</head>
<body>

    <h1>&pi; Pi 极速版</h1>
    <span class="tag">Kernel: Chudnovsky Binary Splitting</span>
    
    <div class="controls">
        <label>
            目标位数:
            <input type="number" id="targetDigits" value="100000" min="100" max="5000000" step="1000">
        </label>
        <button id="btnCalc" onclick="startCalc()">立即计算</button>
    </div>

    <div id="status-text"></div>

    <div class="stats-panel">
        <div class="stat-card">
            <span class="stat-label">总耗时</span>
            <span class="stat-value" id="timeVal">0.00 s</span>
        </div>
        <div class="stat-card">
            <span class="stat-label">实际结果长度</span>
            <span class="stat-value" id="lenVal">0</span>
        </div>
    </div>

    <div id="result-area">准备就绪...</div>

    <script id="worker-code" type="javascript/worker">
        self.onmessage = function(e) {
            const digits = e.data;
            try {
                const startTime = performance.now();
                
                // Chudnovsky 算法常数
                const C = 640320n;
                const C3_OVER_24 = C * C * C / 24n;
                
                // 1. 确定迭代次数
                // Chudnovsky 每项收敛约 14.18 位
                const iterations = Math.floor(digits / 14.18111561) + 1;
                
                self.postMessage({ type: 'status', msg: `正在进行二分分割计算 (Terms: ${iterations})...` });

                // 2. 二分分割 (Binary Splitting) - 递归计算 P, Q, T
                function binarySplit(a, b) {
                    if (b - a === 1n) {
                        // 基本情况
                        const Pab = (6n * a - 5n) * (2n * a - 1n) * (6n * a - 1n);
                        const Qab = a * a * a * C3_OVER_24;
                        const Tab = Pab * (545140134n * a + 13591409n);
                        
                        // 处理 k=0 的特殊情况
                        if (a === 0n) {
                            return { P: 1n, Q: 1n, T: 13591409n };
                        }
                        return { P: Pab, Q: Qab, T: Tab }; // 注意：这里 T 包含了负号逻辑，我们在合并时处理
                    } else {
                        // 递归分割
                        const m = (a + b) / 2n;
                        const left = binarySplit(a, m);
                        const right = binarySplit(m, b);
                        
                        // 合并公式
                        // P = P_left * P_right
                        // Q = Q_left * Q_right
                        // T = T_left * Q_right + P_left * T_right (注意符号交替已经在基本项公式隐含处理，或者需要在这里显式处理)
                        
                        // 更正的标准 Chudnovsky BS 公式：
                        // 对于 (-1)^k ...
                        // 我们在基本情况里：若 k=0, 正. 
                        // 公式通常写为: 
                        // P(a,b) = P(a,m) * P(m,b)
                        // Q(a,b) = Q(a,m) * Q(m,b)
                        // T(a,b) = T(a,m) * Q(m,b) + P(a,m) * T(m,b) 
                        // *但是在 Chudnovsky 中，T 部分的符号是 (-1)^k，通常通过 P 的符号控制*
                        // 这里的简单实现使用了修正后的 Pab 公式：
                        // Pab = -(6k-5)(2k-1)(6k-1)  <-- 包含负号
                        
                        // 让我们使用经过验证的简化版 BS 逻辑:
                        
                        const P = left.P * right.P;
                        const Q = left.Q * right.Q;
                        const T = left.T * right.Q + left.P * right.T;
                        
                        return { P, Q, T };
                    }
                }

                // 修正 Base Case 以匹配标准实现
                function computeBS(a, b) {
                    if (b - a === 1n) {
                        const k = b; // 使用 upper bound 作为 k (除了 0)
                        if (k === 1n) {
                            // k=0 项实际上是在主公式处理，还是这里？
                            // 让我们从 k=0 开始
                        }
                        // 实际上大多实现从 k=1 到 n，k=0 单独加
                        // 这里我们使用区间 [a, b)
                        
                        let Pab, Qab, Tab;
                        
                        if (a === 0n) {
                            Pab = 1n;
                            Qab = 1n;
                            Tab = 13591409n;
                        } else {
                            const k = a;
                            // P_k = (6k-5)(2k-1)(6k-1)
                            // 并在奇数项引入负号，或者直接在 sum 中减
                            // 为了简单，我们将 (-1)^k 放入 Pab
                            Pab = (6n*k - 5n) * (2n*k - 1n) * (6n*k - 1n);
                            Pab = -Pab; // 符号交替
                            
                            Qab = k * k * k * C3_OVER_24;
                            Tab = Pab * (545140134n * k + 13591409n);
                        }
                        return { P: Pab, Q: Qab, T: Tab };
                    } 
                    
                    const m = (a + b) / 2n;
                    const left = computeBS(a, m);
                    const right = computeBS(m, b);
                    
                    const P = left.P * right.P;
                    const Q = left.Q * right.Q;
                    const T = left.T * right.Q + left.P * right.T;
                    return { P, Q, T };
                }

                // 执行 BS
                const BS = computeBS(0n, BigInt(iterations));
                
                self.postMessage({ type: 'status', msg: '正在计算高精度平方根...' });

                // 3. 计算最终结果
                // Pi = (Q * 426880 * sqrt(10005)) / T
                // 需要高精度 sqrt
                
                // 预留额外的精度位数以防舍入误差
                const extraPrecision = 20n; 
                const scale = 10n ** (BigInt(digits) + extraPrecision);
                
                // 计算 sqrt(10005 * scale^2) = sqrt(10005) * scale
                // 使用牛顿迭代法求 sqrt(10005 * 10^(2*digits))
                
                function sqrtBigInt(n) {
                    if (n < 0n) throw 'Negative sqrt';
                    if (n < 2n) return n;
                    
                    let x0 = n;
                    let x1 = (x0 + n / x0) >> 1n;
                    
                    while (x1 < x0) {
                        x0 = x1;
                        x1 = (x0 + n / x0) >> 1n;
                    }
                    return x0;
                }

                // 为了保持精度，先乘 scale 再除
                // Pi = (Q * 426880 * sqrt(10005)) / T
                // 变形为: (Q * 426880 * sqrt(10005 * 10^(2*N))) / (T * 10^N) ?
                // 或者是: (Q * 426880 * sqrt(10005) * 10^N) / T
                
                const one = 10n ** (BigInt(digits) + extraPrecision);
                const sqrtBase = 10005n * (one * one); // 放大以便开方后保留小数
                const sqrtVal = sqrtBigInt(sqrtBase);
                
                self.postMessage({ type: 'status', msg: '正在执行最终除法...' });
                
                const numer = BS.Q * 426880n * sqrtVal;
                const denom = BS.T * one; // 因为 sqrtVal 已经包含了 scale，这里调整分母
                // 修正公式:
                // Pi ~= 426880 * sqrt(10005) * Q / T
                // Numer = 426880 * (sqrt(10005) * scale) * Q
                // Denom = T * scale ? No.
                
                // 让我们直接点：
                // Val = (426880 * Q * sqrt(10005 * 10^(2N))) / T
                // 结果直接是整数形式的 Pi
                
                const finalPi = (426880n * BS.Q * sqrtVal) / BS.T;

                self.postMessage({ type: 'status', msg: '转换结果为文本...' });
                
                let piStr = finalPi.toString();
                // 截取所需位数
                piStr = piStr.slice(0, digits + 1); // +1 是因为 "3" 算一位
                
                // 插入小数点
                if (piStr.length > 1) {
                    piStr = piStr.charAt(0) + "." + piStr.slice(1);
                }

                const endTime = performance.now();
                
                self.postMessage({ 
                    type: 'result', 
                    pi: piStr, 
                    time: (endTime - startTime) 
                });

            } catch (e) {
                self.postMessage({ type: 'error', msg: e.toString() });
            }
        };
    </script>

    <script>
        const workerBlob = new Blob([document.getElementById('worker-code').textContent], { type: 'text/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        let worker = null;

        const btnCalc = document.getElementById('btnCalc');
        const statusText = document.getElementById('status-text');
        const resultArea = document.getElementById('result-area');
        const timeVal = document.getElementById('timeVal');
        const lenVal = document.getElementById('lenVal');

        function startCalc() {
            const digits = parseInt(document.getElementById('targetDigits').value);
            
            if (digits > 5000000) {
                if (!confirm("计算超过 500 万位可能会导致浏览器内存不足崩溃。确定继续吗？")) return;
            }

            if (worker) worker.terminate();
            worker = new Worker(workerUrl);

            // UI Reset
            btnCalc.disabled = true;
            resultArea.innerText = "正在初始化计算引擎...";
            statusText.innerText = "准备中...";
            resultArea.style.opacity = 0.5;

            worker.postMessage(digits);

            worker.onmessage = function(e) {
                const data = e.data;
                
                if (data.type === 'status') {
                    statusText.innerText = data.msg;
                } 
                else if (data.type === 'result') {
                    statusText.innerText = "计算完成";
                    timeVal.innerText = (data.time / 1000).toFixed(3) + " s";
                    
                    // 渲染结果
                    resultArea.style.opacity = 1;
                    resultArea.innerText = data.pi;
                    lenVal.innerText = (data.pi.length - 1).toLocaleString(); // 减去小数点的长度
                    
                    btnCalc.disabled = false;
                }
                else if (data.type === 'error') {
                    statusText.innerText = "错误: " + data.msg;
                    btnCalc.disabled = false;
                }
            };
            
            worker.onerror = function(e) {
                statusText.innerText = "Worker Error: " + e.message;
                btnCalc.disabled = false;
            }
        }
    </script>
</body>
</html>
